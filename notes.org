* Code architecture notes for Arrow/Ivy implementation and benchmarks


** What is the essence of a combination between Arrow and Ivy?

From a node x a request gets sent towards node z which currently holds the token. The request message travels along this path, potentially being transformed during that. Nodes themselves can store a state which can get modified as well.

So the essence is
- Send a request with some initial message state
- Forward a request in a node, potentially changing the request and the node's state
- Node holding the token receives the request, potentially changing the node's state

#+BEGIN_SRC haskell

  -- | Weights to all other nodes from some current node
  -- Indexed by i such that you can access the weight to a specific other node if you know its i, which can be sent along with messages
  type Weights i = UArray i Double

  -- | Algorithm parametrized by the effects r it needs to run
  -- | Not parametrized by the node and message states, as those are internal to the algorithm

  -- | Base algorithm without node state, add state layer above that if needed. Stateless type:

  data Algorithm r = forall m . Algorithm
    { sendRequest
      :: forall i . i -- | Current node index
      -> Sem r (m i)
    , forwardRequest
      :: forall i . m i -- ^ Incoming message
      -> i -- ^ Current node index
      -> Sem r (i, m i) -- ^ Return the next predecessor and message
    , recvRequest
      :: forall i . m i -- ^ Incoming message
      -> i -- ^ Current node index
      -> Sem r i -- ^ Return the next predecessor
    }

  -- | These three fields have almost the same type, the only difference is whether they have an incoming and outgoing message
  -- | Why (m a)? Because the message's state type m will probably want to pass along the current node somehow

  -- | Stateful: (TODO: Make more flexible, combine multiple)

  data StatefulAlgorithm r = forall n . StatefulAlgorithm
    { initialNodeState
      :: forall i . i
      -> Sem r (n i)
    , baseAlgorithm
      :: forall i . Algorithm (State (n i) ': r)
    }

  newtype WithWeights r = WithWeights
    { withoutWeights
      :: forall i
      => Ix i
      -> Algorithm (Reader (Weights i) ': r)
    }
#+END_SRC

Examples:

#+BEGIN_SRC haskell
  newtype ArrowMessage a = ArrowMessage a

  arrow :: Algorithm []
  arrow = Algorithm
    { sendRequest = \myself ->
        return (ArrowMessage myself)
    , forwardRequest = \(ArrowMessage sender) myself ->
        return (sender, ArrowMessage myself)
    , recvRequest = \(ArrowMessage sender) myself ->
        return sender
    }


  newtype IvyMessage a = IvyMessage a

  ivy :: Algorithm []
  ivy = Algorithm
    { sendRequest = \myself ->
        return (IvyMessage myself)
    , forwardRequest = \msg@(IvyMessage root) _ ->
        return (root, msg)
    , recvRequest = \msg@(IvyMessage root) _ ->
        return root
    }

  newtype MiddleMessage a = MiddleMessage [a]

  middle :: Algorithm []
  middle = Algorithm
    { sendRequest = \myself ->
        return (MiddleMessage [myself])
    , forwardRequest = \(MiddleMessage nodes) myself ->
        return (nodes !! (length nodes `div` 2), MiddleMessage (myself : nodes))
    , recvRequest = \(MiddleMessage nodes) myself ->
        return (nodes !! (length nodes `div` 2))
    }
      
#+END_SRC

*** Choose depending on edge weights

What edge weights does a node have access to?
- It can't have access to all edges, because this would be a global view and be impossible to do distributively.
- How about the edges right next to it? That makes sense to have. Space needed as many neighbors there are.
- How about the weights of the edges the request already traveled through? Either accumulated (Monoid, constant space state in the message) or all of them (SetContainer, linear space state in the message). Edit: Not needed, implemented through message state.

Should have access to only one thing: Neighbors and their weights.

But really, since we assume a complete graph, all nodes are neighbors and nodes should be able to get the weight to any of them.

*** Depending on past requests

Nodes might want to e.g. count how many requests they received and influence their choice based on that


#+BEGIN_SRC haskell
  -- | arrow request this -> (nextPredecessor, nextRequest)
  arrow :: a -> a -> Sem r (a, a)
  arrow req this = return (req, this)

  ivy :: a -> a -> Sem r (a, a)
  ivy req this = return (req, req)

  middle :: [a] -> a -> Sem r (a, [a])
  middle req this = return (req !! (length req / 2), this : req)

  alternating :: (a, Maybe a) -> a -> Sem r (a, (a, Maybe a))
  alternating (root, alt) this = return $ case alt of
    Nothing   -> (root, Just this)
    Just prev -> (prev, Nothing)
#+END_SRC

^^ Very promising, can have convenience function for sequence based predecessor selection, since it's a specialization of this

#+BEGIN_SRC haskell
  -- | alg nodes message   chooses a node out of nodes as a new predecessor, while also receiving and determining the message contents
  alg :: MonoFoldable s => NonNull s -> Message -> Sem r (Element s, Message)
#+END_SRC

Initial states? Maybe we need a data type for algorithms with fields for initial node state and initial message state. And the initial tree state! Can we run a separate algorithm just to determine the initial tree state? Probably the longer the request series, the less the initial state matters, so we could just choose a fixed initial state. Maybe the tree with lowest diameter in order to minimize the influence of the initial state. Or the tree that minimizes the summed distance between any pair of nodes. Can we even calculate that?



We need a field for generating a start message, which generates an initial message and has access to and can change the root nodes state.


Do we need access to the predecessor? Well I can't think of anything we could use this for, but why not.


#+BEGIN_SRC haskell



  data NodeState = NodeState
    { nodePredecessor :: 

  data Algorithm = Algorithm
    { makeRequest :: Member (State NodeState) r => Sem r Message
    }
#+END_SRC

Want to use [[https://hackage.haskell.org/package/algebraic-graphs][algebraic-graphs]] library for polymorphic graphs.

- By using [[https://hackage.haskell.org/package/algebraic-graphs-0.4/docs/Algebra-Graph-ToGraph.html][ToGraph]] we can write algorithms polymorphic in the underlying graph representation. But since algorithms might want to access edge weights, we need the [[https://hackage.haskell.org/package/algebraic-graphs-0.4/docs/Algebra-Graph-Labelled-AdjacencyMap.html][Algebra.Graph.Labelled.AdjacencyMap]] module.
- How about instead, we use ToGraph for the underlying graph, but store the edge weights in a 2-dimensional immutable array for fast access (or it can even be mutable later on). We don't need the flexibility of changing edge weights.
- But hold on, we have a complete graph, there's nothing underlying to store, because everything is connected to everything anyways! So we just need to store the edge weights and the spanning tree somehow.

For the edge weights, we use the [[https://hackage.haskell.org/package/array][array]] library because it supports multiple dimensions and random access.

What do to about the spanning tree?

#+BEGIN_SRC haskell
  data Node s = Node
    { successor :: Maybe Int -- ^ Nothing if holding token or request made
    , state     :: s -- ^ Arbitrary state, chosen by the algorithm
    }


  -- | Mutable (ST) array's for keeping the state of all nodes
  -- Nodes 1, 2, 3 -> Array [(0, Nothing), (0, Just 0), (0, Just 1)]
  -- Requests come in as a sequence of integers
#+END_SRC


One graph transformation per request, one runST per request series.
